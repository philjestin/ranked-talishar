// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches(
  match_id,
  game_id,
  format_id,
  match_date,
  match_name,
  player1_id,
  player2_id,
  player1_decklist,
  player2_decklist,
  player1_hero,
  player2_hero,
  created_at,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING match_id, game_id, match_name, player1_id, player2_id, winner_id, loser_id, player1_decklist, player2_decklist, player1_hero, player2_hero, match_date, format_id, created_at, updated_at, in_progress
`

type CreateMatchParams struct {
	MatchID         uuid.UUID      `json:"match_id"`
	GameID          uuid.NullUUID  `json:"game_id"`
	FormatID        uuid.NullUUID  `json:"format_id"`
	MatchDate       time.Time      `json:"match_date"`
	MatchName       sql.NullString `json:"match_name"`
	Player1ID       uuid.NullUUID  `json:"player1_id"`
	Player2ID       uuid.NullUUID  `json:"player2_id"`
	Player1Decklist sql.NullString `json:"player1_decklist"`
	Player2Decklist sql.NullString `json:"player2_decklist"`
	Player1Hero     uuid.NullUUID  `json:"player1_hero"`
	Player2Hero     uuid.NullUUID  `json:"player2_hero"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.queryRow(ctx, q.createMatchStmt, createMatch,
		arg.MatchID,
		arg.GameID,
		arg.FormatID,
		arg.MatchDate,
		arg.MatchName,
		arg.Player1ID,
		arg.Player2ID,
		arg.Player1Decklist,
		arg.Player2Decklist,
		arg.Player1Hero,
		arg.Player2Hero,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.GameID,
		&i.MatchName,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerID,
		&i.LoserID,
		&i.Player1Decklist,
		&i.Player2Decklist,
		&i.Player1Hero,
		&i.Player2Hero,
		&i.MatchDate,
		&i.FormatID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InProgress,
	)
	return i, err
}

const deleteMatch = `-- name: DeleteMatch :exec
DELETE FROM matches
WHERE match_id = $1
`

func (q *Queries) DeleteMatch(ctx context.Context, matchID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteMatchStmt, deleteMatch, matchID)
	return err
}

const getMatchById = `-- name: GetMatchById :one
SELECT match_id, game_id, match_name, player1_id, player2_id, winner_id, loser_id, player1_decklist, player2_decklist, player1_hero, player2_hero, match_date, format_id, created_at, updated_at, in_progress FROM matches
WHERE match_id = $1 LIMIT 1
`

func (q *Queries) GetMatchById(ctx context.Context, matchID uuid.UUID) (Match, error) {
	row := q.queryRow(ctx, q.getMatchByIdStmt, getMatchById, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.GameID,
		&i.MatchName,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerID,
		&i.LoserID,
		&i.Player1Decklist,
		&i.Player2Decklist,
		&i.Player1Hero,
		&i.Player2Hero,
		&i.MatchDate,
		&i.FormatID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InProgress,
	)
	return i, err
}

const getMatchPlayers = `-- name: GetMatchPlayers :many
SELECT winner_id, loser_id FROM matches where match_id = $1
`

type GetMatchPlayersRow struct {
	WinnerID uuid.NullUUID `json:"winner_id"`
	LoserID  uuid.NullUUID `json:"loser_id"`
}

func (q *Queries) GetMatchPlayers(ctx context.Context, matchID uuid.UUID) ([]GetMatchPlayersRow, error) {
	rows, err := q.query(ctx, q.getMatchPlayersStmt, getMatchPlayers, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMatchPlayersRow{}
	for rows.Next() {
		var i GetMatchPlayersRow
		if err := rows.Scan(&i.WinnerID, &i.LoserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatches = `-- name: ListMatches :many
SELECT match_id, game_id, match_name, player1_id, player2_id, winner_id, loser_id, player1_decklist, player2_decklist, player1_hero, player2_hero, match_date, format_id, created_at, updated_at, in_progress FROM matches
ORDER BY match_id
LIMIT $1
OFFSET $2
`

type ListMatchesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMatches(ctx context.Context, arg ListMatchesParams) ([]Match, error) {
	rows, err := q.query(ctx, q.listMatchesStmt, listMatches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.GameID,
			&i.MatchName,
			&i.Player1ID,
			&i.Player2ID,
			&i.WinnerID,
			&i.LoserID,
			&i.Player1Decklist,
			&i.Player2Decklist,
			&i.Player1Hero,
			&i.Player2Hero,
			&i.MatchDate,
			&i.FormatID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InProgress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :one
UPDATE matches
SET
game_id = coalesce($1, game_id),
format_id = coalesce($2, format_id),
match_date = coalesce($3, match_date),
match_name = COALESCE($4, match_name),
player1_decklist = COALESCE($5, player1_decklist),
player2_decklist = COALESCE($6, player2_decklist),
player1_hero = COALESCE($7, player1_hero),
player2_hero = COALESCE($8, player2_hero),
updated_at = COALESCE($9, updated_at),
in_progress = COALESCE($10, in_progress),
winner_id = COALESCE($11, winner_id),
loser_id = COALESCE($12, loser_id),
player1_id = COALESCE($13, player1_id),
player2_id = COALESCE($14, player2_id)
WHERE match_id = $15
RETURNING match_id, game_id, match_name, player1_id, player2_id, winner_id, loser_id, player1_decklist, player2_decklist, player1_hero, player2_hero, match_date, format_id, created_at, updated_at, in_progress
`

type UpdateMatchParams struct {
	GameID          uuid.NullUUID  `json:"game_id"`
	FormatID        uuid.NullUUID  `json:"format_id"`
	MatchDate       sql.NullTime   `json:"match_date"`
	MatchName       sql.NullString `json:"match_name"`
	Player1Decklist sql.NullString `json:"player1_decklist"`
	Player2Decklist sql.NullString `json:"player2_decklist"`
	Player1Hero     uuid.NullUUID  `json:"player1_hero"`
	Player2Hero     uuid.NullUUID  `json:"player2_hero"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	InProgress      sql.NullBool   `json:"in_progress"`
	WinnerID        uuid.NullUUID  `json:"winner_id"`
	LoserID         uuid.NullUUID  `json:"loser_id"`
	Player1ID       uuid.NullUUID  `json:"player1_id"`
	Player2ID       uuid.NullUUID  `json:"player2_id"`
	MatchID         uuid.UUID      `json:"match_id"`
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) (Match, error) {
	row := q.queryRow(ctx, q.updateMatchStmt, updateMatch,
		arg.GameID,
		arg.FormatID,
		arg.MatchDate,
		arg.MatchName,
		arg.Player1Decklist,
		arg.Player2Decklist,
		arg.Player1Hero,
		arg.Player2Hero,
		arg.UpdatedAt,
		arg.InProgress,
		arg.WinnerID,
		arg.LoserID,
		arg.Player1ID,
		arg.Player2ID,
		arg.MatchID,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.GameID,
		&i.MatchName,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerID,
		&i.LoserID,
		&i.Player1Decklist,
		&i.Player2Decklist,
		&i.Player1Hero,
		&i.Player2Hero,
		&i.MatchDate,
		&i.FormatID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InProgress,
	)
	return i, err
}
